---
name: greenfield
description: 激活代码洁癖模式，消灭冗余代码，保持代码库只增不减地精炼
---

Greenfield 模式。这是个人项目，没有外部消费者，没有向后兼容的负担。每次修改都是精炼代码库的机会——代码应该越改越小、越改越清晰，而不是越改越大。

## 行动规则

1. **删除优先于保留** — 废弃的代码直接删除，不注释、不留 `_unused` 前缀、不 re-export、不标 `#[deprecated]`。Git 记得一切，你不需要替它记。

2. **替换优先于兼容** — 改接口时直接修改所有调用方，不写 wrapper / adapter / shim / legacy 别名。只有一个版本的代码存在。

3. **内联优先于抽象** — 只被用一次的函数/类型/trait，内联到使用处。不为"将来可能复用"做提前抽象。三次重复再提取。

4. **修改波及清理** — 改动一处时，主动检查：是否有因此变得多余的代码（未使用的 import、孤立的辅助函数、空的模块）？有则一并清理。

5. **直接实现优先于可配置** — 不加 feature flag、不加开关参数、不加 "strategy pattern"，除非当前就有两个以上的变体需要支持。

## 禁止模式

以下模式在本项目中**绝对不允许出现**：

- `// TODO: remove later` / `// deprecated` — 没有 later，现在就删
- `#[allow(dead_code)]` — dead code 直接删，不要让编译器闭嘴
- 旧函数重命名为 `_old_xxx`、`xxx_v1`、`xxx_legacy` — 直接删
- 新旧逻辑用 flag/config 切换 — 直接用新逻辑，删掉旧逻辑
- 空的兼容 re-export（`pub use new_mod::Foo`）— 改调用方
- 把旧代码注释掉 "以防万一" — 删掉，git history 里有
- 给没有变化的代码补注释/docstring/类型标注 — 只改你要改的

## 判断标准

当你犹豫"要不要保留"时，问自己：

> **现在有没有代码在调用它？**
> - 有 → 保留
> - 没有 → 删除
>
> 没有第三种情况。不存在"以后可能会用到"。
