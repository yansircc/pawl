<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PAWL DASHBOARD</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono:wght@400;700;800&display=swap">
    <style>
        :root {
            --primary: #6FC2FF;
            --secondary: #FFDE00;
            --red: #FF7169;
            --ink: #383838;
            --base: #F4EFEA;
            --success: #068475;
            --error: #E23F35;
            --white: #FFFFFF;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: var(--base);
            color: var(--ink);
            padding: 32px 40px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1, h2 {
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: -0.02em;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--ink);
        }

        .project-path {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(0,0,0,0.05);
            padding: 3px 8px;
            font-size: 12px;
            margin-top: 4px;
        }

        .header-right { text-align: right; }
        .summary-tags { display: flex; gap: 5px; justify-content: flex-end; margin-bottom: 4px; }

        .tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            padding: 2px 7px;
            border: 2px solid var(--ink);
            text-transform: uppercase;
        }

        .refresh-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #999;
        }

        .workflow-bar {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #999;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 28px;
            align-items: start;
        }

        /* --- Task rows --- */
        .task-list { display: flex; flex-direction: column; gap: 6px; }

        .card {
            background: var(--white);
            border: 2px solid var(--ink);
            padding: 0;
        }
        .card.st-running { border-left: 6px solid var(--primary); }
        .card.st-waiting { border-left: 6px solid var(--secondary); }
        .card.st-failed  { border: 2px solid var(--error); border-left: 6px solid var(--error); }
        .card.st-pending { background: #fafafa; opacity: 0.65; }
        .card.st-stopped { background: #fafafa; opacity: 0.55; }

        .card-main {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 14px;
            min-height: 38px;
        }

        .status-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            padding: 2px 0;
            width: 72px;
            text-align: center;
            text-transform: uppercase;
            flex-shrink: 0;
            border: 2px solid var(--ink);
        }
        .status-tag.running   { background: var(--primary); }
        .status-tag.failed    { background: var(--red); color: white; }
        .status-tag.waiting   { background: var(--secondary); }
        .status-tag.completed { background: var(--success); color: white; }
        .status-tag.pending   { background: #eee; color: #999; border-color: #ccc; }
        .status-tag.stopped   { background: #ddd; color: #888; border-color: #bbb; }

        .task-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 800;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .task-desc {
            font-size: 12px;
            color: #999;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .task-deps {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #bbb;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .card-info {
            display: flex;
            align-items: baseline;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }

        .progress-grid {
            display: flex;
            gap: 2px;
            flex-shrink: 0;
        }
        .p-step {
            width: 18px;
            height: 8px;
            border: 1px solid #bbb;
            background: #eee;
        }
        .p-step.success  { background: var(--success); border-color: var(--success); }
        .p-step.current  { background: var(--primary); border-color: #3a9ae0; animation: pulse 1.5s ease-in-out infinite; }
        .p-step.retrying { background: #FF9800; border-color: #E65100; animation: pulse 1.5s ease-in-out infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .p-step.failed   { background: var(--red); border-color: var(--error); }
        .p-step.skipped  { background: #ccc; border-color: #aaa; }

        .card-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #999;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .retry-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            padding: 1px 6px;
            background: #FFF3E0;
            border: 2px solid #E65100;
            color: #E65100;
            text-transform: uppercase;
            white-space: nowrap;
            flex-shrink: 0;
        }

        /* Expandable second row — only for tasks needing attention */
        .card-extra {
            padding: 0 14px 8px 94px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .error-log {
            background: #FFF5F5;
            border: 1px dashed var(--red);
            padding: 6px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--error);
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
        }

        .card-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .next-action {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--ink);
            background: rgba(0,0,0,0.05);
            padding: 1px 6px;
        }

        .blocked-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--error);
        }

        /* --- Event log (sidebar) --- */
        .sidebar-box {
            background: var(--white);
            border: 2px solid var(--ink);
            padding: 8px 10px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        .sidebar-box h2 {
            font-size: 14px;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #eee;
        }

        .ev {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            padding: 3px 0;
            border-bottom: 1px solid #f0f0f0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .ev:last-child { border-bottom: none; }

        .ev-time { color: #bbb; }
        .ev-task { font-weight: 700; margin: 0 4px; }
        .ev-label { color: #888; }
        .ev-label.ok { color: var(--success); }
        .ev-label.fail { color: var(--error); }
        .ev-label.retry { color: #E65100; }
        .ev-label.wait { color: #b60; }
        .ev-label.start { color: var(--primary); }

        .empty-state {
            color: #bbb;
            font-style: italic;
            padding: 16px;
            text-align: center;
            font-size: 13px;
        }
    </style>
</head>
<body>

<header>
    <div>
        <h1 style="font-size: 32px;">PAWL</h1>
        <div class="project-path" id="project-path">loading...</div>
    </div>
    <div class="header-right">
        <div class="summary-tags" id="summary-tags"></div>
        <div class="refresh-label">AUTO-REFRESH 2S</div>
    </div>
</header>

<div class="workflow-bar" id="workflow-bar"></div>

<div class="container">
    <main class="task-list" id="tasks">
        <div class="empty-state">loading...</div>
    </main>
    <aside>
        <div class="sidebar-box" id="events">
            <h2>EVENT LOG</h2>
            <div class="empty-state">loading...</div>
        </div>
    </aside>
</div>

<script>
let lastEventTsMs = 0;
let allEvents = [];

function elapsed(iso) {
    if (!iso) return '';
    const s = Math.floor((Date.now() - new Date(iso).getTime()) / 1000);
    if (s < 60) return s + 's';
    const m = Math.floor(s / 60);
    if (m < 60) return m + 'm' + (s % 60) + 's';
    return Math.floor(m / 60) + 'h' + (m % 60) + 'm';
}

function duration(startIso, endIso) {
    if (!startIso || !endIso) return '';
    const s = Math.floor((new Date(endIso).getTime() - new Date(startIso).getTime()) / 1000);
    if (s < 60) return s + 's';
    const m = Math.floor(s / 60);
    if (m < 60) return m + 'm' + (s % 60) + 's';
    return Math.floor(m / 60) + 'h' + (m % 60) + 'm';
}

function hms(iso) {
    return new Date(iso).toLocaleTimeString('en-GB', {hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

function esc(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function renderSummary(tasks) {
    const c = {};
    tasks.forEach(t => { c[t.status] = (c[t.status]||0) + 1; });
    const order = [
        ['completed','var(--success)','white'],
        ['running','var(--primary)','var(--ink)'],
        ['waiting','var(--secondary)','var(--ink)'],
        ['failed','var(--red)','white'],
        ['pending','#eee','#999'],
        ['stopped','#ddd','#888'],
    ];
    document.getElementById('summary-tags').innerHTML = order
        .filter(([s]) => c[s])
        .map(([s,bg,fg]) => `<span class="tag" style="background:${bg};color:${fg}">${c[s]} ${s.toUpperCase()}</span>`)
        .join('');
}

function topoSort(tasks) {
    // Compute DAG depth: leaf=0, depth=max(dep depths)+1
    const byName = {};
    tasks.forEach(t => { byName[t.name] = t; });
    const depthCache = {};
    function depth(name) {
        if (depthCache[name] !== undefined) return depthCache[name];
        const t = byName[name];
        if (!t || !t.depends || !t.depends.length) return (depthCache[name] = 0);
        return (depthCache[name] = 1 + Math.max(...t.depends.map(d => depth(d))));
    }
    tasks.forEach(t => depth(t.name));
    // Status priority: attention-needing first within same depth
    const statusPri = { failed:0, waiting:1, running:2, stopped:3, pending:4, completed:5 };
    return [...tasks].sort((a, b) => {
        const da = depthCache[a.name] || 0, db = depthCache[b.name] || 0;
        if (da !== db) return da - db;
        const sa = statusPri[a.status] ?? 9, sb = statusPri[b.status] ?? 9;
        return sa - sb;
    });
}

function buildCardHtml(t) {
    const isRetrying = t.retry_count > 0 && ['running','waiting'].includes(t.status);
    const needsAttention = ['failed','waiting','stopped'].includes(t.status);

    // Progress grid
    const grid = t.workflow.map(s => {
        let cls = s.status;
        if (cls === 'current' && isRetrying) cls = 'retrying';
        return `<div class="p-step ${cls}"></div>`;
    }).join('');

    // Meta parts
    const meta = [];
    const cur = t.workflow.find(s => s.status === 'current');
    if (cur) meta.push(cur.name);
    if (t.started_at && ['running','waiting'].includes(t.status)) meta.push(elapsed(t.started_at));
    if (t.started_at && t.updated_at && ['completed','failed','stopped'].includes(t.status)) meta.push(duration(t.started_at, t.updated_at));
    const depsHtml = (t.depends && t.depends.length) ? `<span class="task-deps">← ${t.depends.join(', ')}</span>` : '';

    // Retry badge
    let retryHtml = '';
    if (isRetrying) {
        retryHtml = `<span class="retry-tag">RETRY ${t.retry_count}/${t.max_retries}</span>`;
    }

    // Extra row: error + actions (only when task needs attention)
    let extraHtml = '';
    if (needsAttention) {
        const parts = [];
        if (t.last_feedback) {
            parts.push(`<div class="error-log">${esc(t.last_feedback)}</div>`);
        }
        const actions = [];
        if (t.blocked_by && t.blocked_by.length) {
            actions.push(`<span class="blocked-label">blocked by ${t.blocked_by.join(', ')}</span>`);
        }
        [...(t.suggest||[])].forEach(a => actions.push(`<span class="next-action">${esc(a)}</span>`));
        if (t.prompt) actions.push(`<span class="next-action">${esc(t.prompt)}</span>`);
        if (actions.length) {
            parts.push(`<div class="card-actions">${actions.join(' ')}</div>`);
        }
        if (parts.length) {
            extraHtml = `<div class="card-extra">${parts.join('')}</div>`;
        }
    }

    // State key for diff detection (excludes elapsed time which changes every render)
    const stateKey = `${t.status}|${t.current_step}|${t.retry_count}|${t.last_feedback || ''}`;

    return `<div class="card st-${t.status}" id="task-${t.name}" data-state="${esc(stateKey)}">
            <div class="card-main">
                <span class="status-tag ${t.status}">${t.status}</span>
                <div class="card-info">
                    <span class="task-name">${t.name}</span>
                    <span class="task-desc">${t.description || ''}</span>
                    ${depsHtml}
                </div>
                ${meta.length ? `<div class="card-meta">${meta.join(' · ')}</div>` : ''}
                <div class="progress-grid">${grid}</div>
                <span class="card-meta">${t.current_step}/${t.total_steps}</span>
                ${retryHtml}
            </div>
            ${extraHtml}
        </div>`;
}

function renderTasks(data) {
    document.getElementById('project-path').textContent = data.project_root;
    document.getElementById('workflow-bar').textContent = data.workflow_steps.join(' → ');
    renderSummary(data.tasks);

    const el = document.getElementById('tasks');
    if (!data.tasks.length) { el.innerHTML = '<div class="empty-state">no tasks</div>'; return; }

    const sorted = topoSort(data.tasks);
    const newNames = new Set(sorted.map(t => t.name));

    // Remove non-card elements (loading state) and stale cards
    el.querySelectorAll(':scope > :not(.card)').forEach(e => e.remove());
    el.querySelectorAll('.card').forEach(card => {
        if (!newNames.has(card.id.replace('task-', ''))) card.remove();
    });

    // Update or insert each card
    sorted.forEach((t, i) => {
        const html = buildCardHtml(t);
        const existing = document.getElementById('task-' + t.name);
        if (existing) {
            const newKey = `${t.status}|${t.current_step}|${t.retry_count}|${t.last_feedback || ''}`;
            if (existing.dataset.state !== newKey) {
                existing.outerHTML = html;
            }
            // If state unchanged, don't touch DOM — animation continues
        } else {
            // New card: insert at correct position
            const cards = el.querySelectorAll('.card');
            if (i < cards.length) {
                cards[i].insertAdjacentHTML('beforebegin', html);
            } else {
                el.insertAdjacentHTML('beforeend', html);
            }
        }
    });
}

function eventLabel(e) {
    const s = e.step_name || '';
    switch (e.type) {
        case 'step_started':    return [s + ' started', 'start'];
        case 'step_finished':   return e.detail === 'ok' ? [s + ' done', 'ok'] : [s + ' failed', 'fail'];
        case 'step_yielded':    return [s + ' waiting', 'wait'];
        case 'step_resumed':    return [s + ' resumed', 'ok'];
        case 'step_skipped':    return [s + ' skipped', ''];
        case 'step_reset':      return e.detail === 'auto' ? [s + ' retry', 'retry'] : [s + ' reset', ''];
        case 'task_started':    return ['started', 'start'];
        case 'task_stopped':    return ['stopped', ''];
        case 'task_reset':      return ['reset', ''];
        case 'viewport_lost':   return [s + ' viewport lost', 'fail'];
        default: return [e.type, ''];
    }
}

function renderEvents() {
    const el = document.getElementById('events');
    if (!allEvents.length) { el.innerHTML = '<div class="empty-state">no events yet</div>'; return; }
    el.innerHTML = allEvents.slice(0, 80).map(e => {
        const [label, cls] = eventLabel(e);
        return `<div class="ev"><span class="ev-time">${hms(e.ts)}</span><span class="ev-task">${e.task}</span><span class="ev-label ${cls}">${label}</span></div>`;
    }).join('');
}

async function fetchStatus() {
    try { renderTasks(await (await fetch('/api/status')).json()); } catch(e) {}
}

async function fetchEvents() {
    try {
        const since = lastEventTsMs ? `?since=${lastEventTsMs + 1}` : '';
        const data = await (await fetch(`/api/events${since}`)).json();
        if (data.events && data.events.length) {
            if (!lastEventTsMs) { allEvents = data.events; }
            else { allEvents = [...data.events, ...allEvents]; }
            lastEventTsMs = Math.max(...data.events.map(e => e.ts_ms));
            renderEvents();
        } else if (!lastEventTsMs) { renderEvents(); }
    } catch(e) {}
}

fetchStatus(); fetchEvents();
setInterval(() => { fetchStatus(); fetchEvents(); }, 2000);
</script>

</body>
</html>
